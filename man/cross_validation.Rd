% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.R
\name{cross_validation}
\alias{cross_validation}
\alias{ExpandingWindow}
\alias{SlidingWindow}
\alias{Holdout}
\alias{roll}
\alias{roll.rolling_window}
\alias{cv}
\alias{cv.rolling_window}
\title{Cross-validation}
\usage{
ExpandingWindow(.init = 1L, .step = 1L, .period = NULL)

SlidingWindow(.size = 1L, .step = 1L, .period = NULL)

Holdout(.period = NULL)

roll(object, ...)

\method{roll}{rolling_window}(object, data, h = 1, .f = identity, ..., .id = ".fold")

cv(object, ...)

\method{cv}{rolling_window}(object, data, h, ..., .safely = TRUE, .id = ".fold")
}
\arguments{
\item{.init}{A positive integer for an initial window size.}

\item{.step}{A positive integer for incremental step.}

\item{.period}{\verb{[character(1)]}

A string defining the period to group by. Valid inputs can be roughly
broken into:
\itemize{
\item \code{"year"}, \code{"quarter"}, \code{"month"}, \code{"week"}, \code{"day"}
\item \code{"hour"}, \code{"minute"}, \code{"second"}, \code{"millisecond"}
\item \code{"yweek"}, \code{"mweek"}
\item \code{"yday"}, \code{"mday"}
}}

\item{.size}{A positive integer for window size.}

\item{...}{Depending on the method:
\itemize{
\item \code{roll} : Additional arguments passed on to the mapped function.
\item \code{cv}: Definitions for the models to be used. All models must share the
same response variable.
}}

\item{data}{A \code{tsibble}}

\item{h}{The forecast horizon for cut-off.}

\item{.f}{\verb{[function / formula]}

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.}

\item{.id}{A character naming the new column containing the}

\item{.safely}{If a model encounters an error, rather than aborting the process a \link[=null_model]{NULL model} will be returned instead. This allows for an error to occur when computing many models, without losing the results of the successful models.}
}
\value{
\itemize{
\item \code{roll} : A tibble with results stored in the column defined by \code{.id}.
}

\itemize{
\item \code{cv}: A \link[=fable]{fable object}
}
}
\description{
\code{ExpandingWindow()} and \code{SlidingWindow()} iterate through each time series in
\code{data}, applying \code{.f} to each sub-window. \code{Holdout()} creates a single slice.
}
\details{
Last observations are dropped if they cannot be included in the last slice
because of insufficient data points.

Window parameters \code{.init}, \code{.size}, \code{.step}, and the cutoff \code{h} can be specfied
in terms of calendar periods, or in terms of number of observations
if \code{.period} is NULL. The implementation relies on \code{slider::slide_period()}.
}
\section{Parallel}{


It is possible to estimate models in parallel using the
\href{https://cran.r-project.org/package=future}{future} package. By specifying a
\code{\link[future:plan]{future::plan()}} before estimating the models, they will be computed
according to that plan.
}

\examples{
library(tsibbledata)
library(fable)
  
ExpandingWindow(.init = 10) \%>\% 
  roll(aus_retail, h = 5)

ts <- aus_retail \%>\%
 filter(State \%in\% c("Queensland", "Victoria"), Industry == "Food retailing") 
 
models <- list(
  snaive = SNAIVE(Turnover),
  ets = TSLM(log(Turnover) ~ trend() + season())
)

suppressWarnings({
ExpandingWindow(.init = 25, .step = 1, .period = "year") \%>\% 
  cv(ts, h = 3, !!!models)
})

}
\seealso{
\code{\link[=accuracy]{accuracy()}}
}
